#!/usr/bin/bash
NIRI_CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/niri/config.kdl"
DYNAMIC_NIRIUSH_CONFIG_FILE="${XDG_CONFIG_HOME:-$HOME/.config}/niri/niriush.kdl"

usage() {
    cat <<EOF
Usage: $0 COMMAND [OPTIONS]... ARGUMENTS
Manage niri windows, workspaces, and configuration dynamically.
Commands:
  conf [OPTIONS]...           Manage dynamic niriush configuration
  flock [OPTIONS]...          Arranges matching windows on a workspace/output
  windo [OPTIONS]... ACTION   Perform ACTION on windows matching selection criteria
  help                        Show this help message and exit
Configuration manipulation options for 'config' (can be combined - the effects are applied in order):
  --add LINE                  Add LINE (if not found) to the dynamic niriush configuration file
  --rm LINE                   Remove LINE (if found) from the dynamic niriush configuration file
  --toggle LINE               Toggle LINE in the dynamic niriush configuration file
  --reset                     Reset the dynamic niriush configuration file to default state
Window selection options for 'flock' and 'windo' (can be combined - windows must match all criteria):
  --workspace REFERENCE       Select windows by workspace index, name, or 'focused'
  --output REFERENCE          Select windows by output name or 'focused'
  --app-id APP_ID             Select windows by application ID regex (case insensitive)
  --title TITLE               Select windows by title regex (case insensitive).
  --floating                  Select only floating windows (ignore tiled)
  --tiled                     Select only tiled windows (ignore floating)
  --focused                   Select only focused windows (ignore unfocused)
  --unfocused                 Select only unfocused windows (ignore focused)
  --filter JQ_FILTER          Select windows by custom jq filter (passed directly and entirely to 'jq')
Target selection options for 'flock' ('--to-workspace' doesn't make sense for 'up'/'down' arrangements):
  --to-output OUTPUT          Name of output to move windows to (default is focused output)
  --to-workspace REFERENCE    Index or name of workspace to move windows to (default is focused workspace)
  --mode MODE                 Window arrangement: 'natural', 'up', 'down' and 'fit' (default is 'natural')
Action command options for 'windo':
  --extra-args ARGS           Additional arguments to pass to ACTION
  --id-flag FLAG              Specify the flag to use for specifying window IDs in ACTION (default is --id)
General Options:
  --help, -h                  Show this help message and exit
EOF
}

# niriu.sh is called primarily from key binds with no terminal, so desktop notifications for errors.
error() {
    local message="$1"
    local show_usage="$2"
    local details
    if [ -z "$message" ]; then
        message="${BASH_SOURCE[0]} failed on line ${BASH_LINENO[0]}"
        details=">>>$(head -n "${BASH_LINENO[0]}" "${BASH_SOURCE[0]}" | tail -n 1)"
    fi
    if [ -t 2 ]; then
        echo -e "niriu.sh error: $message\n" >&2
        [ "$details" ] && echo -e "$details\n" >&2
        [ "$show_usage" ] && usage >&2
    else
        notify-send -a 'niriu.sh error' -u critical "$message" "$details"
    fi
    exit 1
}
trap error ERR

# Configuration management.

resetconf() {
    echo "// Dynamically generated by niriu.sh" > "$DYNAMIC_NIRIUSH_CONFIG_FILE"
}

isconf() {
    grep -qxF "$1" "$DYNAMIC_NIRIUSH_CONFIG_FILE"
}

addconf() {
    isconf "$1" || echo "$1" >> "$DYNAMIC_NIRIUSH_CONFIG_FILE"
}

rmconf() {
    if isconf "$1"; then
        grep -vxF "$1" "$DYNAMIC_NIRIUSH_CONFIG_FILE" > "$DYNAMIC_NIRIUSH_CONFIG_FILE.tmp"
        mv "$DYNAMIC_NIRIUSH_CONFIG_FILE.tmp" "$DYNAMIC_NIRIUSH_CONFIG_FILE"
    fi
}

toggleconf() {
    if isconf "$1"; then
        rmconf "$1"
    else
        addconf "$1"
    fi
}

check_configuration_files() {
    if ! grep -qxF "include \"$DYNAMIC_NIRIUSH_CONFIG_FILE\"" "$NIRI_CONFIG_FILE"; then
        [ -t 0 ] || error "Please include $DYNAMIC_NIRIUSH_CONFIG_FILE in $NIRI_CONFIG_FILE"
        echo "$DYNAMIC_NIRIUSH_CONFIG_FILE is not included in $NIRI_CONFIG_FILE" >&2
        read -rp "Include it now? [y/N] " response
        [[ "$response" =~ ^[Yy]$ ]] || error "User declined to include dynamic config file"
        resetconf
        echo "include \"$DYNAMIC_NIRIUSH_CONFIG_FILE\"" >> "$NIRI_CONFIG_FILE"
        niri validate || error "Failed to validate updated $NIRI_CONFIG_FILE, please fix manually"
    fi
}

configure() {
    check_configuration_files
    while [ $# -gt 0 ]; do
        case "$1" in
            --add) shift; addconf "$1";;
            --rm) shift; rmconf "$1";;
            --toggle) shift; toggleconf "$1";;
            --reset) resetconf;;
            *) error "Unknown configuration command: $1" usage;;
        esac
        shift
    done
    niri msg action load-config-file
}

# Window management.

# Generic filtered property getter with `niri msg --json` and `jq`.
get() {
    local object_type="$1"
    shift
    local property="$1"
    shift
    local filter='.[]'
    while [ $# -gt 0 ]; do
        filter="$filter | select($1)"
        shift
    done
    niri msg --json "$object_type" | jq -r "$filter | .$property"
}

# A specific getter for the currently focused output.
# Why don't outputs have an is_focused property like workspaces and windows?
focused_output() {
    niri msg --json focused-output | jq -r ".${1:-name}"
}

windo() {
    # Remember to consume first arguments, so that `$@` contains only the action.
    local window_ids="$1"
    shift
    local window_id_flag="$1"
    shift
    local extra_args="$1"
    shift
    # shellcheck disable=SC2046,SC2086  # We want word splitting on extra_args.
    xargs -I{} niri msg action "$@" $extra_args "$window_id_flag" {} <<<"$window_ids"
}

scatter() {
    local window_ids="$1"
    local to_output_name="$2"
    local mode="$3"
    local to_workspace_idx
    [ "$mode" = down ] && to_workspace_idx=255 || to_workspace_idx=0
    windo "$window_ids" '--id' '' move-window-to-monitor "$to_output_name"
    windo "$window_ids" '--window-id' '--focus false' move-window-to-workspace "$to_workspace_idx"
}

fetch() {
    local window_ids="$1"

    # Can't use `windo` here because workspace idx is relative and may change after moving each window.
    # Instead, we get the current workspace updated idx before each move.
    for window_id in $window_ids; do
        niri msg action move-window-to-monitor "$(focused_output)" --id "$window_id"
        niri msg action move-window-to-workspace "$(get workspaces name '.is_focused == true')" \
            --window-id "$window_id" --focus false
    done
}

calculate_grid_layout() {
    local width=$1
    local height=$2
    local elements=$3
    local aspect_ratio
    local rows
    local columns
    aspect_ratio=$(bc <<< "scale=2; $width / $height")
    rows=$(bc <<< "scale=0; sqrt($elements * $aspect_ratio)/1")
    [ "$rows" -eq 0 ] && rows=1
    columns=$(bc <<< "($elements + $rows - 1) / $rows")
    echo "$rows $columns"
}

fit() {
    local window_ids="$1"
    local width
    local height
    local rows
    local columns
    if [ "$(wc -w <<<"$window_ids")" = 1 ]; then
        niri msg action focus-window --id "$window_ids"
        niri msg action set-window-width '100%' --id "$window_ids"
        niri msg action set-window-height '100%' --id "$window_ids"
        return 0
    fi

    read -r width height < <(focused_output 'logical | "\(.width) \(.height)"')
    read -r rows columns < <(calculate_grid_layout "$width" "$height" "$(wc -w <<<"$window_ids")")

    windo "$window_ids" '--id' '' move-window-to-tiling
    niri msg action focus-column-first
    for ((column = 0; column < columns; column++)); do
        for ((row = 1; row < rows; row++)); do
            niri msg action consume-window-into-column
        done
        niri msg action focus-column-right
    done
    cell_width=$((width / columns))
    windo "$window_ids" '--id' '' set-window-width "$cell_width"
    niri msg action focus-column-first
}

flock() {
    local window_ids="$1"
    local to_output_name="$2"
    local to_workspace_reference="$3"
    local mode="${4:-natural}"

    # Remember focused window (if any) before moving windows to restore focus later.
    local to_window_id
    to_window_id="$(get windows id '.is_focused == true')"
    case "$mode" in
        up|down)
            [ "$to_workspace_reference" ] && error "--to-workspace cannot be used with $mode"
            scatter "$window_ids" "$to_output_name" "$mode"
            ;;
        natural|fit)
            [ "$to_workspace_reference" ] || to_workspace_reference="$(get workspaces name '.is_focused == true')"

            niri msg action focus-monitor "$to_output_name"
            niri msg action focus-workspace "$to_workspace_reference"

            # Scatter windows before fetch to break up existing stacks.
            scatter "$window_ids" "$to_output_name" up

            fetch "$window_ids"
            [ "$mode" = fit ] && fit "$window_ids"
            ;;
    esac
    if [ "$to_window_id" ]; then
        niri msg action focus-window --id "$to_window_id"
    fi
}

# Main entry point.

niriush() {
    local command_name="$1"
    [ "$command_name" ] || error "No command specified" usage
    shift
    case "$command_name" in
        help|--help|-h) usage && exit;;
        conf) configure "$@"; exit;;
        flock|windo)
            local window_ids
            local action=()
            local filters=()
            local windo_id_flag=--id
            local windo_extra_args
            local to_output_name
            local to_workspace_reference
            local mode
            while [ $# -gt 0 ]; do
                case "$1" in
                    --workspace)
                        shift
                        local workspace_id
                        if [ "$1" = "focused" ]; then
                            workspace_id=$(get workspaces id '.is_focused == true')
                        else
                            if [ "$1" -eq "$1" ] 2>/dev/null; then
                                workspace_id=$(get workspaces id ".idx == $1")
                            else
                                workspace_id=$(get workspaces id ".name == \"$1\"")
                            fi
                        fi
                        [ "$workspace_id" ] || return 0  # No such workspace, so no windows.
                        filters+=(".workspace_id == $workspace_id")
                        shift
                        ;;
                    --output)
                        shift
                        local output_name
                        if [ "$1" = "focused" ]; then
                            output_name=$(focused_output)
                        else
                            output_name="$1"
                        fi
                        shift
                        local output_workspace_ids
                        output_workspace_ids="$(get workspaces id ".output == \"$output_name\"")"
                        [ "$output_workspace_ids" ] || return 0  # No workspaces on that output, so no windows.
                        output_workspace_ids="$(tr '\n' ',' <<<"$output_workspace_ids")"
                        output_workspace_ids="(${output_workspace_ids%,})"
                        filters+=(".workspace_id | IN($output_workspace_ids)")
                        ;;
                    --app-id)
                        shift
                        filters+=(".app_id | test(\"$1\"; \"i\")")
                        shift
                        ;;
                    --title)
                        shift
                        filters+=(".title | test(\"$1\"; \"i\")")
                        shift
                        ;;
                    --floating)
                        filters+=(".is_floating == true")
                        shift
                        ;;
                    --tiled)
                        filters+=(".is_floating == false")
                        shift
                        ;;
                    --focused)
                        filters+=(".is_focused == true")
                        shift
                        ;;
                    --unfocused)
                        filters+=(".is_focused == false")
                        shift
                        ;;
                    --filter)
                        shift
                        filters+=("$1")
                        shift
                        ;;
                    --to-output)
                        [ "$command_name" != "flock" ] && error "$command_name does not support $1" usage
                        shift
                        to_output_name="$1"
                        shift
                        ;;
                    --to-workspace)
                        [ "$command_name" != "flock" ] && error "$command_name does not support $1" usage
                        shift
                        to_workspace_reference="$1"
                        shift
                        ;;
                    --mode)
                        [ "$command_name" != "flock" ] && error "$command_name does not support $1" usage
                        [ "$mode" ] && error "Multiple arrangements specified" usage
                        shift
                        case "$1" in
                            natural|up|down|fit) mode="$1";;
                            *) error "Unknown arrangement mode: $1" usage;;
                        esac
                        shift
                        ;;
                    --id-flag)
                        [ "$command_name" != "windo" ] && error "$command_name does not support $1" usage
                        shift
                        windo_id_flag="$1"
                        shift
                        ;;
                    --extra-args)
                        [ "$command_name" != "windo" ] && error "$command_name does not support $1" usage
                        shift
                        windo_extra_args="$1"
                        shift
                        ;;
                    *)
                        [ "$command_name" != "windo" ] && error "unknown argument for $command_name: $1" usage
                        action+=("$1")
                        shift
                        ;;
                esac
            done

            window_ids="$(get windows id "${filters[@]}")"
            [ "$window_ids" ] || exit 0

            if [ "$command_name" = windo ]; then
                windo "$window_ids" "$windo_id_flag" "$windo_extra_args" "${action[@]}"
            elif [ "$command_name" = flock ]; then
                [ "$to_output_name" ] || to_output_name="$(focused_output)"
                flock "$window_ids" "$to_output_name" "$to_workspace_reference" "$mode"
            fi
        ;;
        *) error "Unknown command: $command_name" usage;;
    esac
}

# Only run the script if it's being executed, to allow sourcing.
# shellcheck disable=SC2317  # This makes semantic sense if you consider sourcing vs executing.
if ! return 0 2>/dev/null; then
    set -Eeo pipefail
    niriush "$@"
fi
